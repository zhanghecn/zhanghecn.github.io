(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{428:function(v,_,t){"use strict";t.r(_);var a=t(62),n=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"asm概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#asm概述"}},[v._v("#")]),v._v(" asm概述")]),v._v(" "),t("h2",{attrs:{id:"二进制数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二进制数据"}},[v._v("#")]),v._v(" 二进制数据")]),v._v(" "),t("p",[v._v("学汇编的时候首先要了解二进制数据。")]),v._v(" "),t("p",[v._v("二进制数据中每一个数就是一个bit 也就是位数 (0和1)\n二进制数据都是从右边开始 "),t("strong",[v._v("000000001")]),v._v("\n二进制也分无符号和有符号，有符号就是分正负")]),v._v(" "),t("h3",{attrs:{id:"无符号二进制数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#无符号二进制数"}},[v._v("#")]),v._v(" 无符号二进制数")]),v._v(" "),t("p",[t("strong",[v._v("11111111")]),v._v("一般来说二进制数为8个bit为一个单位 也就是1字节\n而1字节就是\n"),t("code",[v._v("(2^0 + 2^1 + 2^2 +...+2^7) = (2^8-1) = 255")]),v._v("\n的容积")]),v._v(" "),t("p",[v._v("对于无符号二进数转换10进制计算:\n"),t("code",[v._v("00001001 = 2^0 + 2^3 = 1 + 8 = 9")])]),v._v(" "),t("p",[v._v("反之10进制计算二进制就是不断/2看有多少幂次方")]),v._v(" "),t("p",[t("strong",[v._v("加法运算:")])]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("遇2进1\n00000100\n00000111\n--------\n00001011\n")])])]),t("p",[t("strong",[v._v("为了方便阅读，一般还会已16进制形式出现:")]),v._v("\n十六进制范围从"),t("code",[v._v("0-9 A-F")]),v._v("\n如:"),t("code",[v._v("1111 = 15 = F")])]),v._v(" "),t("p",[v._v("十六进制到十进制同二进制到十六进制大同小异 ，以每个位数的幂次方相加 即可\n反之十六进制到十进制就是 不断除以16 看幂次数")]),v._v(" "),t("h3",{attrs:{id:"带符号的二进制数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#带符号的二进制数"}},[v._v("#")]),v._v(" 带符号的二进制数")]),v._v(" "),t("p",[v._v("二进制的负数形式就是一个整数的反码，因为正数+负数要为0")]),v._v(" "),t("p",[v._v("如 "),t("code",[v._v("00000001+(反码)11111110 = 11111111 = 0")]),v._v("\n但由于"),t("code",[v._v("0 = 00000000 = 11111111")]),v._v(" 反码存在两个0，\n切遇到其他的负数相加存在不匹配")]),v._v(" "),t("p",[v._v("所以存在补码，补码很简单就是原来的反码+1")]),v._v(" "),t("p",[v._v("所以  00000001的负数形式就变成 "),t("code",[v._v("(11111110+1) = 11111111 = -1")])]),v._v(" "),t("p",[v._v("衍生出的减法:"),t("code",[v._v("1 + -1 = (00000001 + 11111111) = 1 0000 0000 （去掉高位的1） = 0000 0000 = 0")])]),v._v(" "),t("blockquote",[t("p",[v._v("二进制的减法实际就是加法，一个正数 + 一个负数 并且舍去进位的高位")])]),v._v(" "),t("h2",{attrs:{id:"字符集"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字符集"}},[v._v("#")]),v._v(" 字符集")]),v._v(" "),t("p",[v._v("最先出来的是ANSI编码，但由于不支持中文 有出现了UNICODE 编码 。\n但由于原来的 字符都只占1个直接 到了unicode每个都是两个字节。\n为了节约内存 又在unicode的基础上又出现UTF-8 UTF-16等字符集")]),v._v(" "),t("p",[v._v("对于 ASCLL表 字符集编码对应如下:\n"),t("img",{attrs:{src:"/img_3.png",alt:"img.png"}})]),v._v(" "),t("h2",{attrs:{id:"x86-32位处理器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#x86-32位处理器"}},[v._v("#")]),v._v(" X86 32位处理器")]),v._v(" "),t("ol",[t("li",[v._v("地址空间\n在32位保护环境下 一个任务或程序最大可以寻址4GB的地址空间")]),v._v(" "),t("li",[v._v("基本程序执行寄存器")])]),v._v(" "),t("p",[v._v("寄存器直接位于CPU内高速存储位置，其设计的访问速度高于传统存储区，列入当一个循环处理优化时，一般\n存储在寄存器而不是变量中。")]),v._v(" "),t("p",[v._v("基本程序的执行寄存器 分为8个通用寄存器 6个段寄存器 一个处理器状态标志寄存器(EFLAGS) 和\n一个指令指针寄存EIP,用于控制下次执行指令的地址")]),v._v(" "),t("p",[v._v("通用寄存器\nEAX EBX ECX EDX\nEBP ESP ESI EDI\n通用寄存器一般用于算数运算和数据传输\n一些寄存器组成部位可以处理8位的值 （EAX）AX 高位 为AH 低位为 AL\n其他的EBX ECX EDX 也类似")]),v._v(" "),t("p",[v._v("其他通用寄存器只能用32位 或 16位名称来访问:\nESI SI\nEDI DI\nEBP BP\nESP SP")]),v._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[v._v("用法:")])]),v._v(" "),t("ul",[t("li",[v._v("EAX一般用于乘除运算")]),v._v(" "),t("li",[v._v("ECX一般用于循环计数")]),v._v(" "),t("li",[v._v("ESI和EDI一般用于扩展目的变址")]),v._v(" "),t("li",[v._v("ESP用于寻址堆栈")]),v._v(" "),t("li",[v._v("EBP用来引用函数参数和局部变量")])]),v._v(" "),t("ol",{attrs:{start:"4"}},[t("li",[t("p",[v._v("EFLAGS 寄存器\n用作标识CPU操作结果,1标记0清除")])]),v._v(" "),t("li",[t("p",[v._v("XMM 寄存器\n用于操作浮点类型，在独立的FPU上执行\n操作指令从 ST(0) - ST(7)")])]),v._v(" "),t("li",[t("p",[v._v("32与64位寄存器")])])]),v._v(" "),t("ul",[t("li",[v._v("32位")])]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("一般用于累加数据:EAX , EBX ,EDX\n一般用于循环计数:ECX \n堆栈寻址 ESP\n还有额外的R8D-R15D\n扩展源变址 ESI + EDI（原地址计算变化地址）\n")])])]),t("ul",[t("li",[v._v("64位")])]),v._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("EAX = RAX\nEBX = RBX\nECX = RCX\nEDX = RDX\n(扩展源变址)\nESI = RSI\nEDI = RDI\n(堆栈寻址)\nESP\n(函数参数和局部变量引用)\nEBP\n额外的R8 - R15\n")])])])])}),[],!1,null,null,null);_.default=n.exports}}]);